\renewcommand{\nomebreve}{tower\_of\_hanoi\_pancakes}
\renewcommand{\titolo}{Hanoi tower with two-sided disks}

\introduzione{}

Se non conosci il puzzle classico della torre di Hanoi, o la descrizione quì sotto non basta, chiedi spiegazione in aula. Quì consideriamo una variazione dove i dischi hanno due facce (sono frittelle con una faccia bruciata).
Nella configurazione iniziale non solo tutte le $n$ frittelle si trovano sul primo dei tre pioli, in modo che ogni frittella $i$ poggi sulla frittella immediatamente più grande $i+1$, ma inoltre tutte le frittelle poggiano sul proprio lato bruciacchiato.
Inoltre, ad ogni mossa, la frittella che viene spostata viene anche ribaltata in modo che il lato che immediatamente prima della mossa era rivolto verso l'alto si ritrova come lato su cui la frittella poggia a valle della mossa.

Domanda: è possibile portare la torre dal primo al terzo piolo, spostando (e flippando) una sola frittella alla volta, sempre rispettando il vincolo che nessuna frittella poggi su una frittella più piccola, in modo da giungere infine alla configuraziobe in cui tutte le frittelle si ritrovano sul terzo piolo poggiando sulla faccia bruciata?

Goal~1: la domanda sopra.

Goal~2: si assuma di ricevere in input $n$ bits $b_i$, $i=1,\ldots, n$,
e che lo scopo sia quello di giungere nella configurazione in cui tutte le frittelle sono nel terzo piolo con la frittella $i$ rovesciata (a faccia bruciata in alto) se e solo se $b_i = 1$.

Goal~3: si raggiunga la configurazione finale desiderata impiegando il minimo numero possibile di mosse.

%Goal~4: sempre con l'ambizione di impiegare il minimo numero di mosse,
%        gestire anche il caso in cui si possa avere $b_i = 2$,
%        a significare che la configurazione finale va bene sia che la frittella~$i$ abbia la faccia bruciata verso il basso che verso l'alto.



\sezionetesto{Input ed Output}

Si utilizzi il template di soluzione {\sc tower\_of\_hanoi\_pancakes.cpp}
per gestire lo input e l'output in modo pulito.


% Esempi
\sezionetesto{Esempio di input/output}
\esempio{
1

0
}{2

Muovi il disco 1 dal piolo 1 al piolo 2

Muovi il disco 1 dal piolo 2 al piolo 3
}
\esempio{
1

1
}{1

Muovi il disco 1 dal piolo 1 al piolo 3
}
\esempio{
2

0 1
}{3

Muovi il disco 1 dal piolo 1 al piolo 2

Muovi il disco 2 dal piolo 1 al piolo 3

Muovi il disco 1 dal piolo 2 al piolo 3
}

% Assunzioni
\sezionetesto{Assunzioni e note}
\begin{itemize}[nolistsep, noitemsep]
  \item $1 \le n \le 20$.
\end{itemize}
  
\section*{Subtask}
%Un'istanza \'e risolta correttamente quando la sequenza di mosse prodotta porta la torre in una configurazione finale desiderata: il numero di tali configurazioni finali \'e uno solo qualora $b \in \{0,1\}^n$  ma pu\'o essere fino a $2^n$ dato che se $b_i = 2$ allora la frittella $b_i$ pu\'o essere orientata sia con la faccia bruciata verso il basso che verso l'alto.
Ciascuno dei seguenti subtask fornisce gi\`a met\`a
dei suoi punti quando si pervenga in qualche modo alla configurazione finale.
Fornisce punteggio pieno se il numero delle mosse è minimo possibile.
\'E in ogni caso a carico dello studente che il numero riportato nella prima riga del file {\sc output.txt} prodotto dalla sua soluzione coincida col numero di mosse poi elencate (se sono elencate meno mosse il file {\sc output.txt} verr\'a considerato corrotto, se di pi\'u, allora il prefisso delle sole mosse dichiarate nella prima riga non condur\'a alla soluzione finale desiderata).

  \begin{itemize}
    \item \textbf{Subtask 1 [0 punti]:} i due esempi del testo.
%    \item \textbf{Subtask 2 [10 punti]:} $10 \le n \le 20$, $b_i=2$ per ogni $i=1,\ldots, n$.
    \item \textbf{Subtask 2 [20/40 punti]:} $1 \le n \le 10$, $b_i=0$ per ogni $i=1,\ldots, n$.
    \item \textbf{Subtask 3 [20/40 punti]:} $1 \le n \le 10$, vettore $b$ generico.
    \item \textbf{Subtask 4 [5/10 punti]:} $10 \le n \le 20$, vettore $b\equiv \mathbf{0}$.
    \item \textbf{Subtask 5 [5/10 punti]:} $10 \le n \le 20$, vettore $b$ generico.
  \end{itemize}
  
